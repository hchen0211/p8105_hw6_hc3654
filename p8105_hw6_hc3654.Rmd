---
title: "p8105_hw6_hc3654"
output: github_document
---

```{r}
library(tidyverse)
library(modelr)
library(mgcv)
```

# Problem 1:

```{r}
cities_df <- read_csv("https://raw.githubusercontent.com/washingtonpost/data-homicides/refs/heads/master/homicide-data.csv")
```

## Clean data

```{r}
cities_clean_df <- cities_df |> 
  mutate(city_state = paste(city,state,sep = ", "), 
         solve = case_when(
          disposition == "Closed without arrest" ~ 0, 
          disposition == "Open/No arrest" ~ 0,
          disposition == "Closed by arrest" ~ 1)) |> 
  filter(!city_state %in% c("Dallas, TX", "Phoenix, AZ", "Kansas City, MO", "Tulsa, AL")) |> 
  filter(victim_race %in% c("White", "Black")) |> 
  mutate(victim_age = as.numeric(victim_age
  )) 
  
```

## Regression

```{r}
fit_log = cities_clean_df |> 
  filter(city_state == "Baltimore, MD") |> 
  glm(solve ~ victim_race + victim_sex + victim_age, data = _, family = binomial()) |> 
  broom::tidy(conf.int = TRUE)

fit_log

```

```{r}
fit_log |> 
   filter(term == "victim_sexMale") |> 
  mutate(OR = exp(estimate), OR_lower = exp(conf.low), OR_higher = exp(conf.high)) |>
  select(term, OR, OR_lower, OR_higher) |> 
  knitr::kable(digits = 3)
```

## For all cities

```{r}


odds_ratios_cities <- cities_clean_df |>
  group_by(city_state) |>
  nest() |> 
  mutate(
    model_results = purrr::map(
      .x = data,
      .f = ~ glm(solve ~ victim_race + victim_sex + victim_age, 
                 data = .x, 
                 family = binomial()) |>
             broom::tidy(conf.int = TRUE))) |> 
      unnest(model_results) |> 
filter(term == "victim_sexMale") |> 
  mutate(OR = exp(estimate), OR_lower = exp(conf.low), OR_higher = exp(conf.high)) |>
  select(term, OR, OR_lower, OR_higher) |> 
  arrange(OR)

odds_ratios_cities |> 
  select(-term)

odds_ratios_cities|> 
ggplot(aes(x = OR, y = fct_reorder(city_state, OR)))+
  geom_point()+
  geom_errorbarh(aes(xmin = OR_lower, xmax = OR_higher), 
                 height = 0.2, 
                 color = "darkgray")
```

### Comment:

The plot reveals that the adjusted Odds Ratio (OR) is less than 1 for the majority of cities, indicating a prevailing pattern where female victims' homicides have a higher solved advantage (odds) than those of male victims.

However, a crucial finding is that the confidence interval for the OR includes 1 for most cities. This means we lack sufficient statistical evidence to claim a significant gender difference in clearance rates in the majority of locations.

The results highlight two extremes: New York, NY, exhibits the strongest disparity (OR lowest), where the difference in solved odds between male and female victims is most pronounced and statistically significant. Conversely, Albuquerque, NM, holds the highest OR, suggesting male victims' cases are either equally or more likely to be solved there, it's not significant due to including the 1.0.

The clustering of most OR estimates between 0.5 and 1.0 confirms that while a bias exists, the magnitude of the disadvantage for male victims is generally moderate to significant across the cities, driving the overall conclusion that female victims' homicides are generally more likely to be solved across the dataset.

# Problem 2:

```{r}
library(p8105.datasets)
data("weather_df")
```

```{r}
weather_cleaned_df = weather_df |> 
  na.omit()

fit_t <- lm(tmax ~ tmin + prcp, data = weather_cleaned_df) 

fit_t |> 
  broom::tidy() |> 
  filter(term == "tmin"| term == "prcp") |> 
  select(term, estimate) |> 
  pivot_wider(
    names_from = term,
    values_from = estimate
  ) |> 
  mutate(ratio = tmin/prcp) |> 
  select(ratio)


fit_t |> 
  broom::glance() |> 
  select(r.squared)

```

```{r}
set.seed(1)

fit_bootstrap = 
  weather_cleaned_df |> 
  bootstrap(n = 5000) |> 
  mutate(
    df = map(strap, as_tibble),
    fits = map(df, \(df) lm(tmax ~ tmin + prcp, data = df))
  ) |> 
  mutate(r_squared = map_dbl(fits, 
                        .f = ~ broom::glance(.x) |> pull(r.squared)
    )) |>
  mutate(
      beta_ratio = map_dbl(fits, 
                         .f = ~ broom::tidy(.x) |> 
                           filter(term %in% c("tmin", "prcp")) |> 
                           select(term, estimate) |> 
                           pivot_wider(names_from = term, values_from = estimate) |> 
                           mutate(ratio = tmin / prcp) |>
                           pull(ratio))) |> 
  select(.id, r_squared, beta_ratio)

```

### For R\^2

```{r}
ggplot(fit_bootstrap, aes(x = r_squared)) +
  geom_density(fill = "lightblue", alpha = 0.6) +
  labs(title = "Bootstrap Distribution of R-squared", x = "R^2 Estimate") +
  theme_minimal()


fit_bootstrap |>
  summarize(
    R2_lower = quantile(r_squared, 0.025),
    R2_upper = quantile(r_squared, 0.975)
  ) |> 
    knitr::kable(digits = 3)
```
Comments: Here is the plot of distribution for R^2. We can see in most of the Beta Ratio estimate is between 0.93 to 0.95, The highest density is around -0.943. From the table I saw the lower bound for the 95% CI of beta ratio is 0.934. Upper Bound is -0.947. Which confirmed the results from our plot. 



### For Beta(1) / Beta(2)

```{r}
ggplot(fit_bootstrap, aes(x = beta_ratio)) +
  geom_density(fill = "lightblue", alpha = 0.6) +
  labs(title = "Bootstrap Distribution of Beta Ratio", x = "Beta Ratio Estimate") +
  theme_minimal()


fit_bootstrap |>
  summarize(
    Ratio_lower = quantile(beta_ratio, 0.025, na.rm = TRUE),
    Ratio_upper = quantile(beta_ratio, 0.975, na.rm = TRUE)
  ) |> 
    knitr::kable(digits = 3)
```

Comments: Here is the plot of distribution for Beta(1)/Beta(2). We can see in most of the Beta Ratio estimate is between -100 to -300, The highest density is around -170. From the table I saw the lower bound for the 95% CI of beta ratio is -274.795. Upper Bound is -125.484. Which confirmed the results from our plot. 


# Problem 3:

```{r}
baby_df_cleaned = read.csv("birthweight.csv") |> 
  janitor::clean_names() |> 
  mutate(babysex = as.factor(babysex), frace = as.factor(frace), malform = as.factor(malform), mrace = as.factor(mrace), parity = as.factor(parity), smoken = as.factor(smoken)) |> 
  drop_na()


my_mod <- lm(bwt ~ mheight + delwt + mrace + menarche + momage, data = baby_df_cleaned) 


baby_df_cleaned|> 
  add_predictions(my_mod) |> 
  add_residuals(my_mod) |> 
  ggplot(aes(x = pred, y = resid))+
  geom_point(alpha = 0.5)+
  geom_smooth(type = "lm")+
  labs(title = "residuals vs. predictions",
       subtitle = "model: bwt ~ mheight + delwt + mrace ",
       x = "predictions",
       y = "residuals") +
  geom_hline(yintercept = 0, 
             linetype = "dashed") +
  theme_bw()
```

### Comments:

My proposed model (my_mod) is built on a hypothesized structure intended to link easily accessible maternal and timing factors to the final birth weight (bwt, in grams). This selection strategy focuses on core inputs that are hypothesized to influence the environment for fetal growth.

bwt ~ mheight + delwt + mrace + menarche + momage

mheight (Mother's Height): Included to represent maternal structural frame size, which is a structural factor that may underlie fetal size capacity.

delwt (Mother's Delivery Weight): This is used as a measure of maternal nutritional status and overall physical contribution to the pregnancy outcome.

mrace (Mother's Race): Included as a necessary demographic covariate to account for known population-level variations that underly differences in baseline birth weight.

menarche (Menarche Age) and momage (Mother's Age): These factors are selected to adjust for maternal biological maturity and timing, which are hypothesized to affect the efficiency and quality of the reproductive process.

The scatter plot of Residuals vs. Fitted Values shows a wide, symmetric dispersion of points around the zero line, suggesting the model captures the overall linear trend reasonably well. The homoscedasticity (constant variance) assumption is largely met, as the spread of the residuals is consistent across the fitted range.

While the smoothing curve indicates a minor, shallow deviation from perfect linearity, this trend is not systematic or strong enough to invalidate the model. The bulk of the predictions (up to 3500g) show minimal average residual deviation. Therefore, this model provides a reasonable first-order linear approximation using the selected maternal factors.

```{r}
# Other two models
main_effs_mod = lm(bwt ~ blength + gaweeks, data = baby_df_cleaned)

three_ways_mod = lm(bwt ~ bhead + blength+ babysex, data = baby_df_cleaned)
```

```{r}
# Comparison 

cv_df = 
  modelr::crossv_mc(baby_df_cleaned, n = 100) |> 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  )

cv_df_fits <- cv_df |>
  mutate(
    my_mod_fit = map(train, \(df) lm(my_mod, data = df)),
    main_effs_mod_fit = map(train, \(df) lm(main_effs_mod, data = df)),
    three_ways_mod_fit = map(train, \(df) lm(three_ways_mod, data = df))
  ) |> 
  mutate(
    rmse_my_mod = map2_dbl(my_mod_fit, test, modelr::rmse),
    rmse_main_effs = map2_dbl(main_effs_mod_fit, test, modelr::rmse),
    rmse_three_ways = map2_dbl(three_ways_mod_fit, test, modelr::rmse)
  )


cv_df_fits |>
  select(starts_with("rmse_")) |>
  pivot_longer(everything(), names_to = "model", values_to = "rmse") |>
  group_by(model) |>
  summarize(
    mean_rmse = mean(rmse),
    .groups = "drop"
  ) |> 
  knitr::kable(digits = 3)


cv_df_fits |> 
  select(rmse_main_effs, rmse_three_ways, rmse_my_mod) |> 
  pivot_longer(
    everything(),
    names_to = "mod",
    values_to = "rmse",
    names_prefix = "rmse_"
  ) |> 
  ggplot(aes(x = mod, y = rmse, fill = mod))+
  geom_violin()
```

### Comments: 

The results strongly indicate that Model 3 (rmse_three_ways) is the optimal predictive model for birth weight among the three tested structures.

Best Performance (rmse_three_ways): The lowest mean RMSE (288.584) is clearly demonstrated by the blue violin plot. Its shape is centered at the lowest point on the RMSE axis, confirming the best predictive performance on unseen data. The relative narrowness of this violin suggests the error is also highly stable across the 100 test splits.

Worst Performance (rmse_my_mod): The highest mean RMSE (466.596) is shown by the green violin plot. Its position is the highest on the axis, showing that the maternal-focused model consistently produced the largest errors.

Intermediate Performance (rmse_main_effs): The red violin is centered between the two extremes, confirming its moderate predictive capability.